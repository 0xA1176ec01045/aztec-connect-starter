// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.6.6 <0.8.10;

import {Vm} from "../Vm.sol";

import {DefiBridgeProxy} from "./../../aztec/DefiBridgeProxy.sol";
import {RollupProcessor} from "./../../aztec/RollupProcessor.sol";

// Compound-specific imports
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {CompoundBridgeContract} from "./../../bridges/compound/CompoundBridge.sol";

import {AztecTypes} from "./../../aztec/AztecTypes.sol";


import "../../../lib/ds-test/src/test.sol";


contract CompoundTest is DSTest {

    Vm vm = Vm(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);

    DefiBridgeProxy defiBridgeProxy;
    RollupProcessor rollupProcessor;

    CompoundBridgeContract compoundBridge;

    IERC20 constant  dai = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    IERC20 constant cdai = IERC20(0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643);
    IERC20 constant ceth = IERC20(0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5);


    function _aztecPreSetup() internal {
        defiBridgeProxy = new DefiBridgeProxy();
        rollupProcessor = new RollupProcessor(address(defiBridgeProxy));
    }

    function setUp() public {
        _aztecPreSetup();

        compoundBridge = new CompoundBridgeContract(
            address(rollupProcessor)
        );

        _setTokenBalance(address(dai), address(0xdead), 42069);
    }


    function testCompoundBridge() public {
        uint256 depositAmount = 150000000000000;
        vm.deal(address(rollupProcessor), depositAmount);
        _setTokenBalance(address(dai), address(rollupProcessor), depositAmount);


        //AztecTypes.AztecAsset memory empty;
        //AztecTypes.AztecAsset memory inputAsset = AztecTypes.AztecAsset({
        //    id: 1,
        //    erc20Address: address(0x0000000000000000000000000000000000000000),
        //    assetType: AztecTypes.AztecAssetType.ETH
        //});
        //AztecTypes.AztecAsset memory outputAsset = AztecTypes.AztecAsset({
        //    id: 2,
        //    erc20Address: address(ceth),
        //    assetType: AztecTypes.AztecAssetType.ERC20
        //});
        AztecTypes.AztecAsset memory empty;
        AztecTypes.AztecAsset memory inputAsset = AztecTypes.AztecAsset({
            id: 1,
            erc20Address: address(dai),
            assetType: AztecTypes.AztecAssetType.ERC20
        });
        AztecTypes.AztecAsset memory outputAsset = AztecTypes.AztecAsset({
            id: 2,
            erc20Address: address(cdai),
            assetType: AztecTypes.AztecAssetType.ERC20
        });

        (
            uint256 outputValueA,
            uint256 outputValueB,
            bool isAsync
        ) = rollupProcessor.convert(
                address(compoundBridge),
                inputAsset,
                empty,
                outputAsset,
                empty,
                depositAmount,
                1,
                0
            );

        uint256 rollupcDai = cdai.balanceOf(address(rollupProcessor));
        //uint256 rollupcEth = ceth.balanceOf(address(rollupProcessor));

        assertLt(
            rollupcDai,
            depositAmount,
            "cDai received exceeds DAI deposited"
        );
        assertGt(
            rollupcDai,
            0,
            "cDAI received is zero"
        );
        //assertLt(
        //    rollupcEth,
        //    depositAmount,
        //    "cEth received exceeds ETH deposited"
        //);
        //assertGt(
        //    rollupcEth,
        //    0,
        //    "cETH received is zero");
        //assertLt(
        //    rollupcDai,
        //    depositAmount,
        //    "cDAI received exceeds DAI deposited"
        //);
        //assertGt(
        //    0,
        //    rollupcDai,
        //    "cDAI received is zero");

    }


    function assertNotEq(address a, address b) internal {
        if (a == b) {
            emit log("Error: a != b not satisfied [address]");
            emit log_named_address("  Expected", b);
            emit log_named_address("    Actual", a);
            fail();
        }
    }


    function _setTokenBalance(
        address token,
        address user,
        uint256 balance
    ) internal {
        uint256 slot = 2; // May vary depending on token

        vm.store(
            token,
            keccak256(abi.encode(user, slot)),
            bytes32(uint256(balance))
        );

        assertEq(IERC20(token).balanceOf(user), balance, "wrong balance");
    }



}
